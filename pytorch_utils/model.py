# -*- coding: utf-8 -*-
"""Forwardpass_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jrnTVi9kn_jCjQhUG4BwNv16VE5BTKMW

* This notebook is solely for forwardpass only.
* See [here](https://github.com/Cadene/pretrained-models.pytorch) for ResNet, DenseNet, SE-ResNet and [here](https://github.com/lukemelas/EfficientNet-PyTorch) for EfficientNet.
* [Check out our note](https://hackmd.io/0b_n-7lFRMKBgbQvHufn3g?both).
"""

# install model
## ResNet, DenseNet, SE-ResNet
!pip install pretrainedmodels
## EfficientNet
!pip install efficientnet_pytorch

import torch
import torch.nn as nn
import torch.nn.functional as F
import pretrainedmodels
import pretrainedmodels.utils as utils
from efficientnet_pytorch import EfficientNet
import numpy as np

# All available models inpretrainedmodels
print(pretrainedmodels.model_names)

class Bengali_Model(nn.Module):
    def __init__(self, hidden_dim, dropout, model_name):
        super(Bengali_Model, self).__init__()
        self.hidden_dim = hidden_dim
        self.model_name = model_name # just for record

        if model_name.find('efficientnet') == 0:
            self.cnn = EfficientNet.from_name(model_name)
            self.cnn._conv_stem = nn.Conv2d(1, 32, 3, stride=1, padding=0)
            dim_feats= self.cnn._fc.in_features
          
        else:
            self.cnn = pretrainedmodels.__dict__[model_name](num_classes=1000, 
                                                              pretrained=None)
            if model_name.find('resnet') == 0:
                self.cnn.conv1 = nn.Conv2d(1, 64, 3, stride=1, padding=0)
            elif model_name.find('densenet') == 0:
                self.cnn.features.conv0 = nn.Conv2d(1, 64, 3, stride=1, padding=0)
            elif model_name.find('se_resnet') == 0:
                self.cnn.layer0.conv1 = nn.Conv2d(1, 64, 3, stride=1, padding=0)
            dim_feats = self.cnn.last_linear.in_features  
        
        self.linear_x_1 = nn.Linear(dim_feats, hidden_dim)
        self.linear_x_2 = nn.Linear(hidden_dim, 168)
        self.linear_y_1 = nn.Linear(dim_feats, hidden_dim)
        self.linear_y_2 = nn.Linear(hidden_dim, 11)
        self.linear_z_1 = nn.Linear(dim_feats, hidden_dim)
        self.linear_z_2 = nn.Linear(hidden_dim, 7)

        self.dropout    = nn.Dropout(p=dropout) if dropout else None
        self.pool       = nn.AdaptiveAvgPool2d((1,1))
        '''
        The pooling:
        Note that the pool here is for GlobalAveragePooling for now
        May change in the future.
        
        In efficientnet:
        The out_channel 32 may be defined in the hyperparameter
        We follow this number for now.
        
        '''
    
    def features(self, input):
        if self.model_name.find('efficientnet') == 0:
            return self.cnn.extract_features(input)
        else:
            return self.cnn.features(input)

    def logits_x(self, input):
        if self.model_name.find('efficientnet') == 0:
            output_x = self.pool(input)
            if not self.dropout:
                output_x = self.dropout(output_x)
            output_x = output_x.view(output_x.size(0), -1)
            output_x = self.linear_x_1(output_x)
            output_x = F.relu(output_x)
            if not self.dropout:
                output_x = self.dropout(output_x)
            output_x = self.linear_x_2(output_x)
            return output_x
        elif self.model_name.find('resnet') == 0:
            output_x = self.pool(input)
            output_x = output_x.view(output_x.size(0), -1)
            output_x = self.linear_x_1(output_x)
            output_x = F.relu(output_x)
            output_x = self.dropout(output_x)
            output_x = self.linear_x_2(output_x)
            return output_x
        elif self.model_name.find('densenet') == 0:
            output_x = F.relu(input, inplace = True)
            output_x = self.pool(output_x)
            output_x = output_x.view(output_x.size(0), -1)
            output_x = self.linear_x_1(output_x)
            output_x = F.relu(output_x)
            output_x = self.dropout(output_x)
            output_x = self.linear_x_2(output_x)
            return output_x
        elif self.model_name.find('se_resnet') == 0:
            output_x = self.pool(input)
            if not self.dropout:
              output_x = self.dropout(output_x)
            output_x = output_x.view(output_x.size(0), -1)
            output_x = self.linear_x_1(output_x)
            output_x = F.relu(output_x)
            if not self.dropout:
              output_x = self.dropout(output_x)
            output_x = self.linear_x_2(output_x)
            return output_x

    def logits_y(self, input):
        if self.model_name.find('efficientnet') == 0:
            output_y  = self.pool(input)
            if not self.dropout:
                output_y  = self.dropout(output_y)
            output_y =  output_y.view(output_y.size(0), -1)
            output_y  = self.linear_y_1(output_y)
            output_y  = F.relu(output_y)
            if not self.dropout:
                output_y  = self.dropout(output_y)
            output_y  = self.linear_y_2(output_y)
            return output_y
        elif self.model_name.find('resnet') == 0:
            output_y  = self.pool(input)
            output_y  = output_y.view(output_y.size(0), -1)
            output_y  = self.linear_y_1(output_y)
            output_y  = F.relu(output_y)
            output_y  = self.dropout(output_y)
            output_y  = self.linear_y_2(output_y)
            return output_y
        elif self.model_name.find('densenet') == 0:
            output_y  = F.relu(input, inplace = True)
            output_y  = self.pool(output_y)
            output_y =  output_y.view(output_y.size(0), -1)
            output_y  = self.linear_y_1(output_y)
            output_y  = F.relu(output_y)
            output_y  = self.dropout(output_y)
            output_y  = self.linear_y_2(output_y)
            return output_y
        elif self.model_name.find('se_resnet') == 0:
            output_y  = self.pool(input)
            if not self.dropout:
              output_y  = self.dropout(output_y)
            output_y =  output_y.view(output_y.size(0), -1)
            output_y  = self.linear_y_1(output_y)
            output_y  = F.relu(output_y)
            if not self.dropout:
              output_y  = self.dropout(output_y)
            output_y  = self.linear_y_2(output_y)
            return output_y

    def logits_z(self, input):
        if self.model_name.find('efficientnet') == 0:
            output_z  = self.pool(input)
            if not self.dropout:
                output_z  = self.dropout(output_z)
            output_z =  output_z.view(output_z.size(0), -1)
            output_z  = self.linear_z_1(output_z)
            output_z  = F.relu(output_z)
            if not self.dropout:
                output_z  = self.dropout(output_z)
            output_z  = self.linear_z_2(output_z)
            return output_z
        elif self.model_name.find('resnet') == 0:
            output_z  = self.pool(input)
            output_z  = output_z.view(output_z.size(0), -1)
            output_z  = self.linear_z_1(output_z)
            output_z  = F.relu(output_z)
            output_z  = self.dropout(output_z)
            output_z  = self.linear_z_2(output_z)
            return output_z
        elif self.model_name.find('densenet') == 0:
            output_z  = F.relu(input, inplace = True)
            output_z  = self.pool(output_z)
            output_z =  output_z.view(output_z.size(0), -1)
            output_z  = self.linear_z_1(output_z)
            output_z  = F.relu(output_z)
            output_z  = self.dropout(output_z)
            output_z  = self.linear_z_2(output_z)
            return output_z
        elif self.model_name.find('se_resnet') == 0:
            output_z  = self.pool(input)
            if not self.dropout:
              output_z  = self.dropout(output_z)
            output_z =  output_z.view(output_z.size(0), -1)
            output_z  = self.linear_z_1(output_z)
            output_z  = F.relu(output_z)
            if not self.dropout:
              output_z  = self.dropout(output_z)
            output_z  = self.linear_z_2(output_z)
            return output_z



    def forward(self, input):
        output     = self.features(input)
        output_x   = self.logits_x(output)
        output_y   = self.logits_y(output)
        output_z   = self.logits_z(output)
        
        return output_x, output_y, output_z

# produce random square image input
input_tensor = torch.rand((1, 1, 64, 64))
input_Bengal = torch.autograd.Variable(input_tensor,
    requires_grad=False)

model = Bengali_Model(1,0.5, 'se_resnet152')
model(input_Bengal)

'densenet201'.find('densenet')

